package repositories

import (
	"github.com/google/uuid"
	"github.com/l3montree-dev/devguard/internal/core"

	"github.com/l3montree-dev/devguard/internal/database/models"
	"gorm.io/gorm"
)

type AggregatedVulnRepository struct {
	firstPartyVulnerabilityRepository firstPartyVulnerabilityRepository
	dependencyVulnRepository          dependencyVulnRepository
}

func (a AggregatedVulnRepository) FindByTicketID(tx core.DB, ticketID string) (models.Vuln, error) {
	firstPartyVuln, err := a.firstPartyVulnerabilityRepository.FindByTicketID(tx, ticketID)
	if err != nil {
		// maybe a dependency vuln
		dependencyVuln, err := a.dependencyVulnRepository.FindByTicketID(tx, ticketID)
		if err != nil {
			return nil, err
		}
		return &dependencyVuln, nil
	}
	return &firstPartyVuln, nil
}

func (a AggregatedVulnRepository) GetOrgFromVuln(vuln models.Vuln) (models.Org, error) {
	if _, ok := vuln.(*models.FirstPartyVulnerability); ok {
		return a.firstPartyVulnerabilityRepository.GetOrgFromVulnID(nil, vuln.GetID())
	}
	return a.dependencyVulnRepository.GetOrgFromVulnID(nil, vuln.GetID())
}

type VulnStats struct {
	TotalRisk           float64 `json:"total_risk"`
	AvgRisk             float64 `json:"avg_risk"`
	MaxRisk             float64 `json:"max_risk"`
	DependencyVulnCount int64   `json:"dependencyVuln_count"`
	PackageName         string  `json:"package_name"`
}

type VulnerabilityRepository[T Tabler] struct {
	db core.DB
	Repository[string, T, core.DB]
}

func NewVulnerabilityRepository[T Tabler](db core.DB) *VulnerabilityRepository[T] {
	return &VulnerabilityRepository[T]{
		db:         db,
		Repository: newGormRepository[string, T](db),
	}
}

func (r *VulnerabilityRepository[T]) GetByAssetId(
	tx *gorm.DB,
	assetId uuid.UUID,
) ([]T, error) {

	var vulns []T = []T{}
	// get all vulnerabilities of the asset
	if err := r.Repository.GetDB(tx).Where("asset_id = ?", assetId).Find(&vulns).Error; err != nil {
		return nil, err
	}
	return vulns, nil
}

func (r *VulnerabilityRepository[T]) GetAllVulnsByAssetID(tx core.DB, assetID uuid.UUID) ([]T, error) {
	var dependencyVulns []T = []T{}
	if err := r.Repository.GetDB(tx).Where("asset_id = ?", assetID).Find(&dependencyVulns).Error; err != nil {
		return nil, err
	}
	return dependencyVulns, nil
}

func (r *VulnerabilityRepository[T]) GetAllOpenVulnsByAssetVersionNameAndAssetId(tx core.DB, assetVersionName string, assetID uuid.UUID) ([]T, error) {
	var vulns []T = []T{}
	if err := r.Repository.GetDB(tx).Where("asset_version_name = ? AND asset_id = ? AND state = ?", assetVersionName, assetID, models.VulnStateOpen).Find(&vulns).Error; err != nil {
		return nil, err
	}
	return vulns, nil
}

func (r *VulnerabilityRepository[T]) FindByTicketID(tx core.DB, ticketID string) (T, error) {
	var vuln T
	if err := r.Repository.GetDB(tx).Where("ticket_id = ?", ticketID).First(&vuln).Error; err != nil {
		return vuln, err
	}
	return vuln, nil
}
