package vulndb

import (
	"archive/zip"
	"context"
	"encoding/json"
	"io"
	"log/slog"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/l3montree-dev/flawfix/internal/database"
	"github.com/l3montree-dev/flawfix/internal/database/models"
)

type githubExploitDBService struct {
	exploitRepository exploitRepository
	httpClient        *http.Client
}

type githubExploitRepository interface {
	SaveBatch(tx database.DB, exploits []models.Exploit) error
}

func NewGithubExploitDBService(exploitRepository githubExploitRepository) githubExploitDBService {
	return githubExploitDBService{
		exploitRepository: exploitRepository,
		httpClient:        &http.Client{},
	}
}

var githubExploitDBURL = "https://github.com/nomi-sec/PoC-in-GitHub/archive/refs/heads/master.zip"

func (s *githubExploitDBService) fetchGithubExploits(ctx context.Context) error {
	// download exploits from the github repository
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, githubExploitDBURL, nil)
	if err != nil {
		slog.Info("Error while downloading the file %s", err)
		return err
	}

	res, err := s.httpClient.Do(req)
	if err != nil {
		slog.Info("Error while downloading the file %s", err)
		return err
	}

	defer res.Body.Close()

	// Create the file
	zipFile, err := os.Create("exploits.zip")
	if err != nil {
		slog.Info("Error while creating the file %s", err)
		return err
	}
	defer zipFile.Close()

	// Write the body to file
	_, err = io.Copy(zipFile, res.Body)
	if err != nil {
		slog.Info("Error while writing the file %s", err)
		return err
	}

	// Unzip the file
	zipListing, err := zip.OpenReader("exploits.zip")
	if err != nil {
		slog.Info("Error while unzipping the file %s", err)
		return err
	}

	defer zipListing.Close()

	// Read the json files and save them to the database

	//make exploits map
	exploits := make(map[string]models.Exploit, 0)

	// iterate over the files in the zip
	for _, f := range zipListing.File {
		// check if the file is a json file
		if strings.HasSuffix(f.Name, ".json") {

			// extract the CVE name from the file name
			splitPath := strings.Split(f.Name, "/")
			cveNameWithExtension := splitPath[len(splitPath)-1]
			cveName := strings.TrimSuffix(cveNameWithExtension, ".json")
			if !strings.HasPrefix(cveName, "CVE") {
				continue
			}

			//tmp to save alle exploits from one json file
			var tmp []models.Exploit

			// read the json file and convert it to byte array
			jsonFile, _ := f.Open()
			defer jsonFile.Close()
			byteValue, err := io.ReadAll(jsonFile)
			if err != nil {
				slog.Info("Error while reading the json file %s", err)
				return err
			}

			// parse the json file
			err = json.Unmarshal(byteValue, &tmp)
			if err != nil {
				slog.Info("Error while parsing the json file %s", err)
				return err
			}

			for _, exploit := range tmp {

				id := "github" + strconv.Itoa(exploit.LocalID)

				exploitModel := models.Exploit{
					ID:          id,
					Published:   exploit.Published,
					Updated:     exploit.Updated,
					Author:      exploit.Owner.Login,
					Type:        exploit.Type,
					Verified:    exploit.Verified,
					SourceURL:   exploit.SourceURL,
					Description: exploit.Description,
					CVEID:       cveName,
					Tags:        exploit.Tags,
					Forks:       exploit.Forks,
					Watchers:    exploit.Watchers,
					Subscribers: exploit.Subscribers,
					Stars:       exploit.Stars,
				}

				//save the exploit in the map
				if existingExploit, exist := exploits[id]; exist {
					// check the dateUpdated, maybe it is more recent
					if exploit.Updated != nil && existingExploit.Updated != nil && exploit.Updated.After(*existingExploit.Updated) {
						exploits[id] = exploitModel
					}
				} else {
					exploits[id] = exploitModel
				}
			}

		}

	}

	// get all values of the map
	exploitModels := make([]models.Exploit, len(exploits))
	i := 0
	for _, exploitModel := range exploits {
		exploitModels[i] = exploitModel
		i++
	}

	// save the exploits to the database
	return s.exploitRepository.SaveBatch(nil, exploitModels)
}

func (s githubExploitDBService) Mirror() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	return s.fetchGithubExploits(ctx)
}
